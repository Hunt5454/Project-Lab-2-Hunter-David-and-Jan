// This program  is to be ran as a simulation of the parsing code on the Arduino.
// Once our Arduino is in this code will be ran on the Arduino.
// See https://bblanchon.github.io/ArduinoJson/assistant/
#include <iostream>
#include "ArduinoJson.h"
#include <string>
void CreateMap(float c1x,float c1y,float c2x,float c2y,float c3x,float c3y,float c4x,float c4y);
 int EnemyGoalCheck(int team);
 float EnemyGoalCheckSpace(int team, int number);
bool ballhalf(int team);
bool half(int team, char shape);
//int GoalPath(int team, string shape);
 int Infront(int team,  char shape);
//bool BallClose(int team, const char* shape);
int behind(int team,  char shape);
void hasBall(int team, char shape);
int mostspace(int team, char shape);
bool triangleopen(int team);
void circlekick(int team);
void trianglekick(int team);
int goalspace(int team);
float LeftBound[4];
 float RightBound[4];
 float TopBound[4];
 float BottomBound[4];
 float goalLeft[4];
 float goalRight[4];
 float midpoint;
float BTX;
float BTY;
float BSX;
float BSY;
float BCX;
float BCY;
float RTX;
float RTY;
float RSX;
float RSY;
float RCX;
float RCY;
float BX;
float BY;
float halfy;
float rsx;
float rtx;
float rcx;

int main()
{
  // Memory pool for JSON object tree.

  
 
 const size_t bufferSize = JSON_ARRAY_SIZE(4) + 11*JSON_OBJECT_SIZE(2) + 2*JSON_OBJECT_SIZE(3) + 8*JSON_OBJECT_SIZE(4) + 7*JSON_OBJECT_SIZE(6) + 1410;
DynamicJsonBuffer jsonBuffer(bufferSize);

  const char* json ="{\"Ball\":{\"Object Center\":{\"X\":240.1168,\"Y\":149.2336},\"Bounding Box\":{\"X Left\":233,\"Y Top\":142,\"X Right\":248,\"Y Bottom\":157},\"Area\":137,\"Orientation\":153.0431,\"Aspect Ratio\":1,\"Nb Holes\":1},\"Corners\":[{\"X\":12.0495,\"Y\":210.9505},{\"X\":414.7983,\"Y\":197.7204},{\"X\":32.96965,\"Y\":39.06929},{\"X\":380.2392,\"Y\":22.04729}],\"Red Team Data\":{\"Circle\":{\"Object Center\":{\"X\":137.058,\"Y\":103.4375},\"Bounding Box\":{\"X Left\":126,\"Y Top\":93,\"X Right\":149,\"Y Bottom\":115},\"Area\":224,\"Orientation\":25.44606,\"Aspect Ratio\":1.045455,\"Nb Holes\":1},\"Square\":{\"Object Center\":{\"X\":87.07018,\"Y\":91.53947},\"Bounding Box\":{\"X Left\":76,\"Y Top\":81,\"X Right\":99,\"Y Bottom\":103},\"Area\":228,\"Orientation\":31.23487,\"Aspect Ratio\":1.045455,\"Nb Holes\":1},\"Triangle\":{\"Object Center\":{\"X\":133.7784,\"Y\":58.8125},\"Bounding Box\":{\"X Left\":126,\"Y Top\":51,\"X Right\":145,\"Y Bottom\":68},\"Area\":176,\"Orientation\":10.87619,\"Aspect Ratio\":1.117647,\"Nb Holes\":1}},\"Blue Team Data\":{\"Circle\":{\"Object Center\":{\"X\":355.0485,\"Y\":119.489},\"Bounding Box\":{\"X Left\":344,\"Y Top\":109,\"X Right\":367,\"Y Bottom\":131},\"Area\":227,\"Orientation\":149.8406,\"Aspect Ratio\":1.045455,\"Nb Holes\":1},\"Square\":{\"Object Center\":{\"X\":291.5776,\"Y\":95.96983},\"Bounding Box\":{\"X Left\":280,\"Y Top\":86,\"X Right\":304,\"Y Bottom\":107},\"Area\":232,\"Orientation\":166.9183,\"Aspect Ratio\":1.142857,\"Nb Holes\":1},\"Triangle\":{\"Object Center\":{\"X\":291.5459,\"Y\":54.35204},\"Bounding Box\":{\"X Left\":280,\"Y Top\":45,\"X Right\":301,\"Y Bottom\":64},\"Area\":196,\"Orientation\":175.8742,\"Aspect Ratio\":1.105263,\"Nb Holes\":1}}}";


 
  
  JsonObject& root = jsonBuffer.parseObject(json);

JsonObject& Ball = root["Ball"];

float BX = Ball["Object Center"]["X"]; // 240.1168
float BY = Ball["Object Center"]["Y"]; // 149.2336


int Ball_Area = Ball["Area"]; // 137
float Ball_Orientation = Ball["Orientation"]; // 153.0431
int Ball_Aspect_Ratio = Ball["Aspect Ratio"]; // 1
int Ball_Nb_Holes = Ball["Nb Holes"]; // 1

JsonArray& Corners = root["Corners"];

float Corners0_X = Corners[0]["X"]; // 12.0495
float Corners0_Y = Corners[0]["Y"]; // 210.9505

float Corners1_X = Corners[1]["X"]; // 414.7983
float Corners1_Y = Corners[1]["Y"]; // 197.7204

float Corners2_X = Corners[2]["X"]; // 32.96965
float Corners2_Y = Corners[2]["Y"]; // 39.06929

float Corners3_X = Corners[3]["X"]; // 380.2392
float Corners3_Y = Corners[3]["Y"]; // 22.04729

JsonObject& Red_Team_Data = root["Red Team Data"];

JsonObject& Red_Team_Data_Circle = Red_Team_Data["Circle"];

float RCX = Red_Team_Data_Circle["Object Center"]["X"]; // 137.058
float RCY = Red_Team_Data_Circle["Object Center"]["Y"]; // 103.4375



JsonObject& Red_Team_Data_Square = Red_Team_Data["Square"];

float RSX = Red_Team_Data_Square["Object Center"]["X"]; // 87.07018
float RSY = Red_Team_Data_Square["Object Center"]["Y"]; // 91.53947



JsonObject& Red_Team_Data_Triangle = Red_Team_Data["Triangle"];

float RTX = Red_Team_Data_Triangle["Object Center"]["X"]; // 133.7784
float RTY= Red_Team_Data_Triangle["Object Center"]["Y"]; // 58.8125


JsonObject& Blue_Team_Data = root["Blue Team Data"];

JsonObject& Blue_Team_Data_Circle = Blue_Team_Data["Circle"];

BCX= Blue_Team_Data_Circle["Object Center"]["X"]; // 355.0485
BCY = Blue_Team_Data_Circle["Object Center"]["Y"]; // 119.489


JsonObject& Blue_Team_Data_Square = Blue_Team_Data["Square"];

BSX = Blue_Team_Data_Square["Object Center"]["X"]; // 291.5776
BSY = Blue_Team_Data_Square["Object Center"]["Y"]; // 95.96983




JsonObject& Blue_Team_Data_Triangle = Blue_Team_Data["Triangle"];

BTX = Blue_Team_Data_Triangle["Object Center"]["X"]; // 291.5459
BTY = Blue_Team_Data_Triangle["Object Center"]["Y"]; // 54.35204


  // Print value as test.
 // std::cout << "The X coordinate of Corner 0 is "<<Corners0_X << std::endl;
 //std::cout << "The Y coordinate of Corner 0 is "<<Corners0_Y << std::endl;
 //std::cout << "The X coordinate of Corner 1 is "<<Corners1_X << std::endl;
// std::cout << "The Y coordinate of Corner 1 is "<<Corners1_Y << std::endl;
 //std::cout << "The X coordinate of Corner 2 is "<<Corners2_X << std::endl;
 //std::cout << "The Y coordinate of Corner 2 is "<<Corners2_Y << std::endl;
 //std::cout << "The X coordinate of Corner 3 is "<<Corners3_X << std::endl;
 //std::cout << "The Y coordinate of Corner 3 is "<<Corners3_Y << std::endl;
   CreateMap(Corners0_X,Corners0_Y,Corners1_X,Corners1_Y,Corners2_X,Corners2_Y,Corners3_X,Corners3_Y);
    //std::cout << "midpoint is "<<midpoint << std::endl;
    //std::cout << "Amount in Enemy GoalBox is "<<EnemyGoalCheck(1) << std::endl;
   /* if (ballhalf(1)) 
    {   std::cout << "Ball is on  Enemy Half" << std::endl;
    }
    else
    {
        std::cout<<"Ball is on  Our Half"<<std::endl;
    }
    */
    
   // std::cout<<"Enemy Players in front of Square: " <<Infront(1, 'S')<<std::endl;
   // std::cout<<"Enemy Players behind Circle: " <<behind(1, 'C')<<std::endl;
    //std::cout<<"Enemy Players in front of Triangle: " <<Infront(1, 'T')<<std::endl;
   // hasBall(1,'S');
   // std::cout<<"Ball x: "<<BX<<std::endl;
   // std::cout<<"Ball y: "<<BY<<std::endl;
   // std::cout<<"Red Square x: "<<RSX<<std::endl;
  //  std::cout<<"Red Square y: " <<RSY<<std::endl;
  //  mostspace(1,'S');
  // triangleopen(1);
   ////// Kicking1
    BSX=408;
    BSY=116;
    BTX=130;
    BTY=130;
    BCX=164;
    BCY=113;
    RSX=20;
    RSY=117;
    RTX=317;
    RTY=111;
    RCX=180;
    RCY=155;
    BX=183;
    BY=152;
    CreateMap(Corners0_X,Corners0_Y,Corners1_X,Corners1_Y,Corners2_X,Corners2_Y,Corners3_X,Corners3_Y);
    circlekick(1);
    BSX=412;
    BSY=100;
    BTX=130;
    BTY=130;
    BCX=200;
    BCY=90;
    RSX=20;
    RSY=117;
    rtx=RTX;
    rsx=RSX;
    rcx=RCX;
    //std::cout<<RTX<<std::endl;
   
    RTY=111;
    RCX=180;
    RCY=155;
    BX=315;
    BY=113;
    CreateMap(Corners0_X,Corners0_Y,Corners1_X,Corners1_Y,Corners2_X,Corners2_Y,Corners3_X,Corners3_Y);
   //std::cout<<"Is circle on offensive or defenseive"<< half(1,'C')<<std::endl;
    ////////Kicking 2
    //std::cout<<RTX<<std::endl;
   
  trianglekick(1);
    //::cout<<RTX<<std::endl;
   
  return 0;
} 





void CreateMap(float c1x,float c1y,float c2x,float c2y,float c3x,float c3y,float c4x,float c4y){
  LeftBound[0]=c2x;
  LeftBound[1]=c1x;
    LeftBound[2]=c1y;
    LeftBound[3]=c2y;
  RightBound[0]=c3x;
    RightBound[1]=c4x;
    RightBound[2]=c3y;
    RightBound[3]=c4y;
  TopBound[0]=c1x;
    TopBound[1]=c3x;
    TopBound[2]=c1y;
    TopBound[3]=c3y;
  BottomBound[0]=c2x;
     BottomBound[1]=c4x;
     BottomBound[2]=c4y;
     BottomBound[3]=c2y;
  goalLeft[0]=c2x;
    goalLeft[1]=c1x ;
    goalLeft[2]=(c1y+c2y)/4;
    goalLeft[3]=3*(c1y+c2y)/4;
  goalRight[0]=c4x;
     goalRight[1]=c2x;
     goalRight[2]=(c2y+c4y)/4;
     goalRight[3]=3*(c2y+c4y)/4;
  midpoint=(c2x+c1x+c3x+c4x)/4;
  halfy=(c1y+c2y+c3y+c4y)/4;
}
int EnemyGoalCheck(int team){
    int count =0;
    if(team)
    {
     
          if  (((BTX >goalRight[0]-30 &&  BTX <goalRight[1])) && ((BTY >goalRight[2]) &&  (BTY <goalRight[3])) )
          {
              count++;
    }
  if  (((BCX >goalRight[0]-30 &&  BCX <goalRight[1])) && ((BCY >goalRight[2]) &&  (BCY <goalRight[3])) )
    {
        count++;
    }
        
 if  (((BSX >goalRight[0]-30 &&  BSX <goalRight[1])) && ((BSY >goalRight[2]) &&  (BSY <goalRight[3])) )    {
        count++;
    }
    }
        return count;

}


bool ballhalf(int team){
    
    if (team){
        
        if (BX>midpoint){
            return true;
        }
   }
    else {
        return false;
    }
    
   
}

int Infront(int team, char shape){
    int frontcount=0;
    if (team){
        
       if (shape=='S')
       {
          if(BTX>rsx){
              frontcount++;
            //  std::cout<<frontcount<<std::endl;
       }
            if(BCX>rsx){
              frontcount++;
               //   std::cout<<frontcount<<std::endl;
       }
            if(BSX>RSX){
              frontcount++;
                 // std::cout<<frontcount<<std::endl;
       }
           return frontcount;
       }
           
           if (shape=='C')
              {
          if(BTX>rcx){
              frontcount++;
       }
            if(BCX>rcx){
              frontcount++;
       }
            if(BSX>rcx){
              frontcount++;
       }
           return frontcount;
       }
               
               if(shape=='T')
                  {
          if(BTX>rtx){
              frontcount++;
               
       }
            if(BCX>rtx){
              frontcount++;
                
                  
       }
            if(BSX>rtx){
              frontcount++;
                
                  
       }      
           return frontcount;
       }
    }
}
void hasBall(int team, char shape){
    if (team){
        
       if (shape=='S')
       {
       if ((BX<RSX+8 && BX>RSX)&&(BY<RSY-4 && BY>RSY+4)){
           std::cout<<"Square Has the Ball "<<std::endl;
           
       }
           else{
           std::cout<<"Square Doesn't have the ball"<<std::endl;
           }
       }
           if (shape=='C')
           {
               
               if ((BX<RCX+8 && BX>RCX)&&(BY<RCY-4 && BY>RCY+4)){
                  std::cout<<"Circle Has the Ball "<<std::endl;
       }
                else{
           std::cout<<"Circle Doesn't have the ball"<<std::endl;
           }
           }
               if(shape=='T')
                  {
        if ((BX<RTX+8 && BX>RTX)&&(BY<RTY-4 && BY>RTY+4)){
            
             std::cout<<"Triangle Has the Ball "<<std::endl;
       }
                    else{
           std::cout<<"Triangle Doesn't have the ball"<<std::endl;
           }
    }
    }

}
    
    
    
    float EnemyGoalCheckSpace(int team, int number){
        
        
        
         if(team&&(number==1))
    {
     
          if  (((BTX >goalRight[0]-30 &&  BTX <goalRight[1])) && ((BTY >goalRight[2]) &&  (BTY <goalRight[3])) )
          {
             return BTY ;
    }
  if  (((BCX >goalRight[0]-30 &&  BCX <goalRight[1])) && ((BCY >goalRight[2]) &&  (BCY <goalRight[3])) )
    {
        return BCY;
    }
        
 if  (((BSX >goalRight[0]-30 &&  BSX <goalRight[1])) && ((BSY >goalRight[2]) &&  (BSY <goalRight[3])) )    {
      return BSY;
    }
    }
       
        
        
        
    }
    
int goalspace(int team){
if (team){
    
    if (EnemyGoalCheckSpace(team,EnemyGoalCheck(team))>halfy){
        return 3;
    
}
    else if (EnemyGoalCheckSpace(team,EnemyGoalCheck(team))<halfy)
    {
    return 1;
    }
}
    
}
    
int behind(int team, char shape){
    int frontcount=0;
    if (team){
        
       if (shape=='S')
       {
          if(BTX<RSX){
              frontcount++;
       }
            if(BCX<RSX){
              frontcount++;
       }
            if(BSX<RSX){
              frontcount++;
       }
           return frontcount;
       }
           
           if (shape=='C')
              {
          if(BTX<RCX){
              frontcount++;
       }
            if(BCX<RCX){
              frontcount++;
       }
            if(BSX<RCX){
              frontcount++;
       }
           return frontcount;
       }
               
               if(shape=='T')
                  {
          if(BTX<RTX){
              frontcount++;
       }
            if(BCX<RTX){
              frontcount++;
       }
            if(BSX<RTX){
              frontcount++;
       }
           return frontcount;
       }
    }
}

bool triangleopen(int team){
    int intersectioncount=0;
    if (team){
   if ((BSX<RCX && BSX>RTX)&&((BSY<RCY-4 && BSY>RTY+4)||(BSY<RTY-4 && BSY>RCY+4))){
        intersectioncount++;
   }
        if ((BCX<RCX && BCX>RTX)&&((BCY<RCY-4 && BCY>RTY+4)||(BCY<RTY-4 && BCY>RCY+4))){
             intersectioncount++;
        }
         if ((BTX<RCX && BTX>RTX)&&((BTY<RCY-4 && BTY>RTY+4)||(BTY<RTY-4 && BTY>RCY+4))){
             intersectioncount++;
        }
   if (intersectioncount==0){
       std::cout<<"Triangle is Open"<<std::endl;
       return true;
   }
        else {
            std::cout<<"Triangle is not Open"<<std::endl;
        return false;
        }
    }
}
        

int mostspace(int team, char shape){
    if (team){
       
           if (Infront(team,shape)==3){
               float avy=(BTY+BSY+BCY)/3;
               std::cout<<"Average of the Three Enemies "<<avy<<std::endl;
                std::cout<<"Halfy line "<<halfy<<std::endl;
               if(avy>halfy) {
            
                   std::cout<<"Most Space left"<<std::endl;
                    return 1;  
             }
              else{
              
                  std::cout<<"Most Space Right"<<std::endl;
                      return 2;
              }   
       if (shape=='S')
       {
           
      if (Infront(team,shape)==1){
          if(BTX>RSX){
             if(BTY<halfy) {
                 std::cout<<"Most Space left"<<std::endl;
                 return 1;   
             }
              else{
                  std::cout<<"Most Space right"<<std::endl;
                  
                  return 2;
              }
              
       }
            if(BCX>RSX){
              if(BCY<halfy) {
             return 1;   
                   std::cout<<"Most Space left"<<std::endl;
             }
              else{
                  return 2;
                   std::cout<<"Most Space right"<<std::endl;
              }
       }
            if(BSX>RSX){
              if(BSY<halfy) {
             return 1;   
             }
              else{
                  return 2;
              }
       }
           
           }
      }
           
       }
           
           if (shape=='C')
              {
         
       }
               
               if(shape=='T')
                  {
         
         
       }
    }
    
              
}
    
    void circlekick(int team){
   
        if (half(1,'C')==0){
        std::cout<<"Circle on Defensive Half"<<std::endl;
        if (triangleopen(1)){
            std::cout<<"Triangle is open so Circle will attempt pass to Triangle"<<std::endl;
    }
    }
    }
void trianglekick(int team){
    std::cout<<"Triangle has ball"<<std::endl;

 if(EnemyGoalCheck(team)==1){
     std::cout<<"1 in the goalbox"<<std::endl;
   //std::cout<<Infront(team,'T')<<std::endl;
     if (1-Infront(team,'T')==0){
         std::cout<<"No others in front"<<std::endl;
     if (goalspace(team)==1){
         std::cout<<"Kick Left"<<std::endl;
     }
         if (goalspace(team)==3){
         std::cout<<"Kick Right"<<std::endl;
     }
     }
 }
     

}

bool half(int team, char shape){

    
      if (team){
        if (shape=='S'){
        if (RSX>midpoint){
            return true;
        }
   }
          if (shape=='C'){
               if (RCX>midpoint){
            return true;
        }
          }
          if (shape=='T'){
               if (RTX>midpoint){
            return true;
        }
          }
    else {
        return false;
    }
      } 
    
   
}
    
